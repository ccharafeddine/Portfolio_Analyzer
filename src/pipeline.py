"""
Analysis pipeline v2 — fully self-contained.

No imports from old codebase. Uses src.analytics.* for all computation.
Adds stress testing, bootstrap Monte Carlo, and risk contribution.
"""

from __future__ import annotations

import json
from dataclasses import dataclass, field
from pathlib import Path
from typing import Callable, Optional

import numpy as np
import pandas as pd

from src.config.models import PortfolioConfig
from src.data.fetcher import fetch_prices
from src.data import transforms as T
from src.analytics.optimization import (
    max_sharpe,
    efficient_frontier,
    sharpe_ratio,
    portfolio_return,
    portfolio_volatility,
)
from src.analytics.regression import (
    capm_regression,
    run_capm_all,
    RegressionResult,
)
from src.analytics.attribution import simple_attribution_from_holdings
from src.analytics.risk import (
    run_stress_tests,
    stress_results_to_df,
    marginal_risk_contribution,
    risk_contribution_pct,
    tail_metrics,
    rolling_correlation,
    StressResult,
)
from src.analytics.hrp import hrp_weights, hrp_linkage_matrix
from src.analytics.rebalance import (
    drift_from_target,
    rebalanced_backtest,
    compute_turnover,
)
from src.analytics.exposure import (
    get_sector_weights,
    get_factor_tilts,
)
from src.analytics.income import (
    compute_income_summary,
    portfolio_income_metrics,
    cumulative_income_series,
)
from src.analytics.simulation import (
    run_all_simulations,
    SimulationResult,
    simulation_summary_df,
)


# ──────────────────────────────────────────────────────────────
# Result containers
# ──────────────────────────────────────────────────────────────


@dataclass
class PortfolioSeries:
    """A named portfolio value time series with computed stats."""

    name: str
    values: pd.Series
    daily_returns: pd.Series = field(init=False)
    ann_return: float = field(init=False)
    ann_vol: float = field(init=False)
    sharpe: float = field(init=False)
    max_dd: float = field(init=False)

    def __post_init__(self):
        self.daily_returns = self.values.pct_change().dropna()
        self.ann_return = T.annualize_return(self.daily_returns)
        self.ann_vol = T.annualize_vol(self.daily_returns)
        self.max_dd = T.max_drawdown(self.values)
        self.sharpe = np.nan

    def compute_sharpe(self, rf_annual: float) -> None:
        self.sharpe = T.sharpe_ratio(self.daily_returns, rf_annual=rf_annual)


@dataclass
class OptimizationResult:
    """Optimal portfolio from mean-variance optimization."""

    weights: pd.Series
    expected_return: float
    expected_vol: float
    sharpe: float
    frontier_returns: np.ndarray
    frontier_vols: np.ndarray


@dataclass
class AnalysisResults:
    """Complete results from a pipeline run."""

    config: PortfolioConfig

    # Price data
    prices: pd.DataFrame = field(default_factory=pd.DataFrame)
    monthly_returns: pd.DataFrame = field(default_factory=pd.DataFrame)

    # Portfolio series
    active: Optional[PortfolioSeries] = None
    passive: Optional[PortfolioSeries] = None
    orp: Optional[PortfolioSeries] = None
    complete: Optional[PortfolioSeries] = None

    # Optimization
    orp_optimization: Optional[OptimizationResult] = None

    # CAPM
    capm_results: list[RegressionResult] = field(default_factory=list)

    # Risk metrics
    correlation_matrix: Optional[pd.DataFrame] = None
    drawdown_metrics: Optional[pd.DataFrame] = None
    tail_risk: Optional[dict] = None
    risk_contribution: Optional[pd.Series] = None

    # Stress testing
    stress_results: list[StressResult] = field(default_factory=list)
    stress_df: Optional[pd.DataFrame] = None

    # Holdings
    holdings: Optional[pd.DataFrame] = None

    # Attribution
    asset_attribution: Optional[pd.DataFrame] = None
    sector_attribution: Optional[pd.DataFrame] = None

    # HRP
    hrp: Optional[PortfolioSeries] = None
    hrp_weights: Optional[pd.Series] = None
    hrp_linkage: Optional[np.ndarray] = None

    # Rebalancing
    rebalanced: Optional[PortfolioSeries] = None
    weight_drift: Optional[pd.DataFrame] = None
    turnover_table: Optional[pd.DataFrame] = None

    # Correlation regime
    correlation_regime: Optional[pd.DataFrame] = None

    # Sector & factor exposure
    sector_weights: Optional[pd.DataFrame] = None
    factor_tilts: Optional[pd.DataFrame] = None

    # Income
    income_summary: Optional[pd.DataFrame] = None
    income_metrics: Optional[dict] = None
    cumulative_income: Optional[pd.Series] = None

    # Monte Carlo
    simulations: list[SimulationResult] = field(default_factory=list)
    simulation_summary: Optional[pd.DataFrame] = None

    # Interpretations (generated by report engine)
    interpretations: Optional[dict] = None


# ──────────────────────────────────────────────────────────────
# Pipeline
# ──────────────────────────────────────────────────────────────

ProgressCallback = Callable[[str, float], None]


class AnalysisPipeline:
    """
    Orchestrates the full portfolio analysis.

    Usage:
        config = PortfolioConfig.load("config.json")
        pipeline = AnalysisPipeline(config)
        results = pipeline.run(progress_callback=my_callback)
    """

    def __init__(
        self,
        config: PortfolioConfig,
        output_dir: str = "outputs",
    ):
        self.config = config
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.results = AnalysisResults(config=config)

    def run(
        self,
        progress: Optional[ProgressCallback] = None,
    ) -> AnalysisResults:
        """Execute the full analysis pipeline."""
        steps: list[tuple[str, Callable]] = [
            ("Fetching price data", self._fetch_data),
            ("Building active portfolio", self._build_active),
            ("Computing rebalance analysis", self._compute_rebalance),
            ("Computing income analytics", self._compute_income),
            ("Building passive portfolio", self._build_passive),
            ("Optimizing (ORP & frontier)", self._optimize),
            ("Running CAPM regressions", self._run_capm),
            ("Computing risk metrics", self._compute_risk),
            ("Running stress tests", self._run_stress_tests),
            ("Building complete portfolio", self._build_complete),
            ("Running attribution", self._run_attribution),
            ("Computing exposures", self._compute_exposure),
            ("Monte Carlo simulation", self._simulate),
            ("Generating reports", self._generate_reports),
            ("Saving outputs", self._save_outputs),
        ]

        total = len(steps)
        for i, (label, step_fn) in enumerate(steps):
            if progress:
                progress(label, i / total)
            try:
                step_fn()
            except Exception as e:
                print(f"[pipeline] Step '{label}' failed: {e}")
                import traceback
                traceback.print_exc()

        if progress:
            progress("Complete", 1.0)

        return self.results

    # ── Step implementations ──

    def _fetch_data(self) -> None:
        all_tickers = sorted(
            set(self.config.tickers + [self.config.benchmark])
        )

        prices = fetch_prices(
            tickers=all_tickers,
            start=self.config.start_date,
            end=self.config.end_date,
        )

        self.results.prices = prices
        self.results.monthly_returns = T.monthly_returns(prices)

        asset_cols = [
            t for t in self.config.tickers
            if t in self.results.monthly_returns.columns
        ]
        if asset_cols:
            self.results.correlation_matrix = (
                self.results.monthly_returns[asset_cols].corr()
            )

    def _build_active(self) -> None:
        prices = self.results.prices
        weights = self.config.weights
        capital = self.config.capital

        available = [t for t in weights if t in prices.columns]
        if not available:
            raise ValueError("None of the weighted tickers have price data.")

        start_ts = pd.Timestamp(self.config.start_date)
        subset = prices.loc[prices.index >= start_ts, available].dropna(how="any")
        if subset.empty:
            raise ValueError("No common trading date for all tickers after start_date.")

        purchase_date = subset.index[0]
        purchase_prices = subset.loc[purchase_date]

        holdings_rows = []
        shares = {}
        total_invested = 0.0

        for ticker in available:
            w = weights[ticker]
            allocation = capital * w
            n_shares = np.floor(allocation / purchase_prices[ticker])
            invested = n_shares * purchase_prices[ticker]

            holdings_rows.append({
                "Ticker": ticker,
                "TargetWeight": w,
                "PurchasePrice": float(purchase_prices[ticker]),
                "Shares": float(n_shares),
                "Invested": float(invested),
            })
            shares[ticker] = n_shares
            total_invested += invested

        holdings_df = pd.DataFrame(holdings_rows)
        holdings_df["RealizedWeight"] = holdings_df["Invested"] / total_invested
        self.results.holdings = holdings_df

        prices_after = prices.loc[prices.index >= purchase_date, available]
        port_value = sum(prices_after[t] * n for t, n in shares.items())
        port_value = port_value.dropna()
        port_value.name = "Active"

        self.results.active = PortfolioSeries("Active", port_value)
        self.results.active.compute_sharpe(self.config.risk_free_rate)

    def _build_passive(self) -> None:
        prices = self.results.prices
        benchmark = self.config.benchmark

        if benchmark not in prices.columns:
            raise ValueError(f"Benchmark {benchmark} not in price data.")

        start_ts = pd.Timestamp(self.config.start_date)
        bench = prices[benchmark].loc[prices.index >= start_ts].dropna()
        if bench.empty:
            raise ValueError(f"No benchmark data after {self.config.start_date}")

        purchase_price = float(bench.iloc[0])
        units = self.config.capital / purchase_price
        passive_value = bench * units
        passive_value.name = "Passive"

        self.results.passive = PortfolioSeries("Passive", passive_value)
        self.results.passive.compute_sharpe(self.config.risk_free_rate)

    def _optimize(self) -> None:
        if not self.config.include_orp:
            return

        rets_m = self.results.monthly_returns
        benchmark = self.config.benchmark

        asset_cols = [
            t for t in self.config.tickers
            if t in rets_m.columns and t != benchmark
        ]
        if len(asset_cols) < 2:
            return

        asset_rets = rets_m[asset_cols].dropna(how="all")

        if benchmark in rets_m.columns:
            aligned = asset_rets.join(rets_m[benchmark], how="inner")
            asset_rets = aligned[asset_cols]

        cov_m = asset_rets.cov()
        mu_a = (1.0 + asset_rets.mean()) ** 12 - 1.0

        bounds = self.config.allocation_bounds
        res = max_sharpe(
            mu_a.values, cov_m.values,
            rf=self.config.risk_free_rate,
            bounds=bounds,
            short_sales=self.config.short_sales,
        )
        weights = pd.Series(res.x, index=asset_cols, name="weight").round(6)

        cov_a = cov_m.values * 12.0
        port_mean = float(weights @ mu_a.values)
        port_vol = float(np.sqrt(weights.values @ cov_a @ weights.values))
        port_sharpe = sharpe_ratio(
            weights.values, mu_a.values, cov_m.values,
            self.config.risk_free_rate,
        )

        W, R, V = efficient_frontier(
            mu_a.values, cov_m.values,
            self.config.frontier_points,
            bounds, self.config.short_sales,
        )

        self.results.orp_optimization = OptimizationResult(
            weights=weights,
            expected_return=port_mean,
            expected_vol=port_vol,
            sharpe=port_sharpe,
            frontier_returns=R,
            frontier_vols=V,
        )

        # Risk contribution for ORP
        self.results.risk_contribution = risk_contribution_pct(weights, cov_a)

        # Build realized ORP value series
        if self.results.active is not None:
            active_start = self.results.active.values.index[0]
            prices_orp = self.results.prices[asset_cols].loc[active_start:].dropna(how="all")
            if not prices_orp.empty:
                nonzero = weights[weights.abs() > 1e-8]
                available_orp = [t for t in nonzero.index if t in prices_orp.columns]
                if available_orp:
                    alloc = nonzero[available_orp] * self.config.capital
                    initial = prices_orp[available_orp].iloc[0]
                    shares_orp = alloc / initial
                    orp_values = (prices_orp[available_orp] * shares_orp).sum(axis=1)
                    orp_values.name = "ORP"

                    self.results.orp = PortfolioSeries("ORP", orp_values)
                    self.results.orp.compute_sharpe(self.config.risk_free_rate)

        # HRP weights
        try:
            hrp_w = hrp_weights(asset_rets)
            self.results.hrp_weights = hrp_w
            self.results.hrp_linkage = hrp_linkage_matrix(asset_rets)

            # Build realized HRP value series
            if self.results.active is not None:
                active_start = self.results.active.values.index[0]
                prices_hrp = self.results.prices[asset_cols].loc[active_start:].dropna(how="all")
                if not prices_hrp.empty:
                    nonzero_hrp = hrp_w[hrp_w.abs() > 1e-8]
                    available_hrp = [t for t in nonzero_hrp.index if t in prices_hrp.columns]
                    if available_hrp:
                        alloc_hrp = nonzero_hrp[available_hrp] * self.config.capital
                        initial_hrp = prices_hrp[available_hrp].iloc[0]
                        shares_hrp = alloc_hrp / initial_hrp
                        hrp_values = (prices_hrp[available_hrp] * shares_hrp).sum(axis=1)
                        hrp_values.name = "HRP"

                        self.results.hrp = PortfolioSeries("HRP", hrp_values)
                        self.results.hrp.compute_sharpe(self.config.risk_free_rate)
        except Exception as e:
            print(f"[pipeline] HRP failed: {e}")

    def _run_capm(self) -> None:
        rets_m = self.results.monthly_returns
        self.results.capm_results = run_capm_all(
            rets_m,
            self.config.tickers,
            self.config.benchmark,
            self.config.risk_free_rate,
        )

    def _compute_risk(self) -> None:
        portfolios = {
            "Active": self.results.active,
            "Passive": self.results.passive,
            "ORP": self.results.orp,
        }
        rows = []
        for name, ps in portfolios.items():
            if ps is None:
                continue
            var95, cvar95 = T.var_cvar(ps.daily_returns, 0.95)
            var99, cvar99 = T.var_cvar(ps.daily_returns, 0.99)
            rows.append({
                "Portfolio": name,
                "MaxDrawdown": ps.max_dd,
                "VaR_95": var95,
                "CVaR_95": cvar95,
                "VaR_99": var99,
                "CVaR_99": cvar99,
            })

        if rows:
            self.results.drawdown_metrics = pd.DataFrame(rows)

        if self.results.active:
            self.results.tail_risk = tail_metrics(self.results.active.daily_returns)

        # Correlation regime detection
        try:
            asset_cols = [
                t for t in self.config.tickers
                if t in self.results.prices.columns
            ]
            if len(asset_cols) >= 2:
                daily_rets = self.results.prices[asset_cols].pct_change().dropna()
                if len(daily_rets) > 63:
                    self.results.correlation_regime = rolling_correlation(
                        daily_rets, window=63
                    )
        except Exception as e:
            print(f"[pipeline] Correlation regime failed: {e}")

    def _run_stress_tests(self) -> None:
        if self.results.active is None or self.results.passive is None:
            return

        self.results.stress_results = run_stress_tests(
            self.results.active.values,
            self.results.passive.values,
        )
        self.results.stress_df = stress_results_to_df(self.results.stress_results)

    def _build_complete(self) -> None:
        if self.results.orp is None or not self.config.include_complete:
            return

        y = self.config.complete_portfolio.y
        rf_daily = (1 + self.config.risk_free_rate) ** (1 / 252) - 1

        orp_vals = self.results.orp.values
        n_days = len(orp_vals)
        rf_path = self.config.capital * (1 + rf_daily) ** np.arange(n_days)
        rf_series = pd.Series(rf_path, index=orp_vals.index)

        complete_vals = y * orp_vals + (1 - y) * rf_series
        complete_vals.name = "Complete"

        self.results.complete = PortfolioSeries("Complete", complete_vals)
        self.results.complete.compute_sharpe(self.config.risk_free_rate)

    def _run_attribution(self) -> None:
        if self.results.holdings is None or self.results.monthly_returns.empty:
            return

        try:
            self.results.asset_attribution = simple_attribution_from_holdings(
                self.results.holdings,
                self.results.monthly_returns,
                self.config.benchmark,
            )
        except Exception as e:
            print(f"[pipeline] Attribution failed: {e}")

    def _compute_rebalance(self) -> None:
        if self.results.holdings is None or self.results.prices.empty:
            return

        try:
            weights = self.config.weights
            tickers = [t for t in weights if t in self.results.prices.columns]
            if not tickers:
                return

            purchase_date = self.results.active.values.index[0] if self.results.active else self.config.start_date

            self.results.weight_drift = drift_from_target(
                self.results.prices, weights, purchase_date,
            )

            rebal_values = rebalanced_backtest(
                self.results.prices.loc[self.results.prices.index >= pd.Timestamp(purchase_date)],
                weights, self.config.capital,
                frequency="quarterly",
            )
            if not rebal_values.empty:
                self.results.rebalanced = PortfolioSeries("Rebalanced", rebal_values)
                self.results.rebalanced.compute_sharpe(self.config.risk_free_rate)

            if self.results.weight_drift is not None and not self.results.weight_drift.empty:
                self.results.turnover_table = compute_turnover(
                    self.results.weight_drift, frequency="quarterly",
                )
        except Exception as e:
            print(f"[pipeline] Rebalance analysis failed: {e}")

    def _compute_income(self) -> None:
        if self.results.holdings is None:
            return

        try:
            self.results.income_summary = compute_income_summary(
                self.results.holdings,
                self.config.start_date,
                self.config.end_date,
            )

            total_invested = float(self.results.holdings["Invested"].sum())
            if self.results.income_summary is not None:
                self.results.income_metrics = portfolio_income_metrics(
                    self.results.income_summary, total_invested,
                )

            self.results.cumulative_income = cumulative_income_series(
                self.results.holdings,
                self.config.start_date,
                self.config.end_date,
            )
        except Exception as e:
            print(f"[pipeline] Income analytics failed: {e}")

    def _compute_exposure(self) -> None:
        if self.results.holdings is None:
            return

        try:
            self.results.sector_weights = get_sector_weights(self.results.holdings)
        except Exception as e:
            print(f"[pipeline] Sector weights failed: {e}")

        try:
            rets_m = self.results.monthly_returns
            benchmark = self.config.benchmark
            asset_cols = [
                t for t in self.config.tickers
                if t in rets_m.columns and t != benchmark
            ]
            if asset_cols and benchmark in rets_m.columns:
                self.results.factor_tilts = get_factor_tilts(
                    rets_m[asset_cols],
                    rets_m[benchmark],
                )
        except Exception as e:
            print(f"[pipeline] Factor tilts failed: {e}")

    def _simulate(self) -> None:
        if self.results.active is None:
            return

        current_val = float(self.results.active.values.iloc[-1])
        daily_rets = self.results.active.daily_returns

        self.results.simulations = run_all_simulations(
            current_value=current_val,
            daily_returns=daily_rets,
            horizon_days=252 * 3,
            n_paths=500,
            seed=42,
        )
        self.results.simulation_summary = simulation_summary_df(
            self.results.simulations
        )

    def _generate_reports(self) -> None:
        try:
            from src.reports.interpreter import generate_full_interpretation
            self.results.interpretations = generate_full_interpretation(self.results)
        except Exception as e:
            print(f"[pipeline] Report generation failed: {e}")

    def _save_outputs(self) -> None:
        orp_opt = self.results.orp_optimization

        summary = {
            "risk_free_rate_annual": self.config.risk_free_rate,
            "portfolio_return": (
                self.results.active.ann_return if self.results.active else None
            ),
            "benchmark_return": (
                self.results.passive.ann_return if self.results.passive else None
            ),
            "portfolio_volatility": (
                self.results.active.ann_vol if self.results.active else None
            ),
            "portfolio_sharpe": (
                self.results.active.sharpe if self.results.active else None
            ),
        }

        if orp_opt:
            summary["max_sharpe_weights"] = orp_opt.weights.to_dict()
            summary["max_sharpe_portfolio"] = {
                "ann_expected_return": orp_opt.expected_return,
                "ann_volatility": orp_opt.expected_vol,
                "sharpe_ratio": orp_opt.sharpe,
            }

        if self.results.capm_results:
            summary["alpha"] = float(
                np.mean([r.alpha for r in self.results.capm_results])
            )
            summary["beta"] = float(
                np.mean([r.beta for r in self.results.capm_results])
            )

        with open(self.output_dir / "summary.json", "w") as f:
            json.dump(summary, f, indent=2, default=str)

        # Holdings
        if self.results.holdings is not None:
            self.results.holdings.to_csv(
                self.output_dir / "holdings_table.csv", index=False
            )

        # Stress tests
        if self.results.stress_df is not None:
            self.results.stress_df.to_csv(
                self.output_dir / "stress_test_results.csv", index=False
            )

        # Clean prices
        if not self.results.prices.empty:
            self.results.prices.to_csv(self.output_dir / "clean_prices.csv")

        # Monthly returns
        if not self.results.monthly_returns.empty:
            self.results.monthly_returns.to_csv(
                self.output_dir / "monthly_returns.csv"
            )

        # CAPM results
        if self.results.capm_results:
            capm_rows = []
            for r in self.results.capm_results:
                capm_rows.append({
                    "Asset": r.ticker,
                    "Alpha": r.alpha,
                    "Beta": r.beta,
                    "t_alpha": r.t_alpha,
                    "t_beta": r.t_beta,
                    "R_squared": r.r_squared,
                })
            pd.DataFrame(capm_rows).to_csv(
                self.output_dir / "capm_results.csv", index=False
            )

        # Performance attribution
        if self.results.asset_attribution is not None:
            self.results.asset_attribution.to_csv(
                self.output_dir / "performance_attribution.csv", index=False
            )

        # Simulation summary
        if self.results.simulation_summary is not None:
            self.results.simulation_summary.to_csv(
                self.output_dir / "simulation_summary.csv", index=False
            )

        # Drawdown metrics
        if self.results.drawdown_metrics is not None:
            self.results.drawdown_metrics.to_csv(
                self.output_dir / "drawdown_metrics.csv", index=False
            )

        # Correlation matrix
        if self.results.correlation_matrix is not None:
            self.results.correlation_matrix.to_csv(
                self.output_dir / "correlation_matrix.csv"
            )

        # Income summary
        if self.results.income_summary is not None:
            self.results.income_summary.to_csv(
                self.output_dir / "income_summary.csv", index=False
            )

        # Factor tilts
        if self.results.factor_tilts is not None:
            self.results.factor_tilts.to_csv(
                self.output_dir / "factor_tilts.csv", index=False
            )

        # Sector weights
        if self.results.sector_weights is not None:
            self.results.sector_weights.to_csv(
                self.output_dir / "sector_weights.csv", index=False
            )

        # Turnover
        if self.results.turnover_table is not None:
            self.results.turnover_table.to_csv(
                self.output_dir / "turnover.csv", index=False
            )
